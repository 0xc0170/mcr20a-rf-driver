/*
 * Copyright (c) 2014-2015 ARM Limited. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "ns_types.h"
#include "platform/arm_hal_interrupt.h"
#include "nanostack/platform/arm_hal_phy.h"
#include "mcr20a-rf-driver/driverRFPhy.h"
#include "MCR20Drv.h"
#include "MCR20Reg.h"
#include "MCR20Overwrites.h"
#include <string.h>

/* PHY constants in symbols */
#define gPhyWarmUpTime_c       9
#define gPhySHRDuration_c     10
#define gPhySymbolsPerOctet_c  2
#define gPhyAckWaitDuration_c 54
#define gCcaCCA_MODE1_c        1

/* MCR20A states */
typedef enum xcvrState_tag{
  gIdle_c,
  gRX_c,
  gTX_c,
  gCCA_c,
  gTR_c,
  gCCCA_c,
}xcvrState_t;

xcvrState_t mPhySeqState;

/*RF receive buffer*/
static uint8_t rf_buffer[RF_BUFFER_SIZE];

static uint8_t rf_use_antenna_diversity = 0;
static uint8_t need_ack = 0;
static uint16_t tx_len = 0;

static uint8_t rf_rnd_rssi = 0;
static int8_t rf_radio_driver_id = -1;
static phy_device_driver_s device_driver;
static uint8_t MAC_address[8] = {1, 2, 3, 4, 5, 6, 7, 8};
static phy_device_channel_info_s channel_info;
static uint8_t mac_tx_handle = 0;

static uint8_t mStatusAndControlRegs[8];
static uint8_t radio_tx_power = 0x17; /* 0 dBm */
static uint8_t rf_phy_channel = 11;
                                    /* 2405   2410    2415    2420    2425    2430    2435    2440    2445    2450    2455    2460    2465    2470    2475    2480 */
static const uint8_t  pll_int[16] =  {0x0B,   0x0B,   0x0B,   0x0B,   0x0B,   0x0B,   0x0C,   0x0C,   0x0C,   0x0C,   0x0C,   0x0C,   0x0D,   0x0D,   0x0D,   0x0D};
static const uint16_t pll_frac[16] = {0x2800, 0x5000, 0x7800, 0xA000, 0xC800, 0xF000, 0x1800, 0x4000, 0x6800, 0x9000, 0xB800, 0xE000, 0x0800, 0x3000, 0x5800, 0x8000};

/* Private functions */
static uint8_t rf_if_read_rnd(void);
static void PhyAbort(void);
static void PhyPpSetPromiscuous(uint8_t mode);
static uint8_t Phy_LqiConvert(uint8_t hwLqi);
static int8_t PhyConvertLQIToRSSI(uint8_t lqi);
static void PhyTimeReadClock(uint32_t *pRetClk);
static void PhyTimeSetEventTimeout(uint32_t *pEndTime);
static int8_t rf_interface_state_control(phy_interface_state_e new_state, uint8_t rf_channel);
static int8_t rf_extension(phy_extension_type_e extension_type,uint8_t *data_ptr);
static int8_t rf_address_write(phy_address_type_e address_type,uint8_t *address_ptr);



/*
 * \brief Read connected radio part.
 *
 * This function only return valid information when rf_init() is called
 *
 * \return
 */
rf_trx_part_e rf_radio_type_read(void)
{
    return FREESCALE_MCR20A;
}

/*
 * \brief Function initialises and registers the RF driver.
 *
 * \param none
 *
 * \return rf_radio_driver_id Driver ID given by NET library
 */
int8_t rf_device_register(void)
{
    rf_trx_part_e radio_type;

    rf_init();

    radio_type = rf_radio_type_read();
    if(radio_type == FREESCALE_MCR20A)
    {
        /*Set pointer to MAC address*/
        device_driver.PHY_MAC = MAC_address;
        device_driver.driver_description = "FREESCALE_MAC";

        //Create setup Used Radio chips

        /*Number of channels in PHY*/
        channel_info.channel_count = 16;
        /*Channel mask 26-11*/
        channel_info.channel_mask = 0x07FFF800;
        /*Type of RF PHY is SubGHz*/
        device_driver.link_type = PHY_LINK_15_4_2_4GHZ_TYPE;

        device_driver.link_channel_info = &channel_info;
        /*Maximum size of payload is 127*/
        device_driver.phy_MTU = 127;
        /*No header in PHY*/
        device_driver.phy_header_length = 0;
        /*No tail in PHY*/
        device_driver.phy_tail_length = 0;
        /*Set address write function*/
        device_driver.address_write = &rf_address_write;
        /*Set RF extension function*/
        device_driver.extension = &rf_extension;
        /*Set RF state control function*/
        device_driver.state_control = &rf_interface_state_control;
        /*Set transmit function*/
        device_driver.tx = &rf_start_cca;
        /*Register device driver*/
        rf_radio_driver_id = arm_net_phy_register(&device_driver);
    }

    return rf_radio_driver_id;
}

/*
 * \brief Function returns the generated 8-bit random value for seeding Pseudo-random generator. This value was generated by reading noise from RF channel in RF initialisation.
 *
 * \param none
 *
 * \return random RSSI value
 */
int8_t rf_read_random(void)
{
    return rf_rnd_rssi;
}

/*
 * \brief Function is a call back for ACK wait timeout.
 *
 * \param none
 *
 * \return none
 */
void rf_ack_wait_timer_interrupt(void)
{
    rf_receive();
}

/*
 * \brief Function is a call back for calibration interval timer.
 *
 * \param none
 *
 * \return none
 */
void rf_calibration_timer_interrupt(void)
{
}

/*
 * \brief Function is a call back for cca interval timer.
 *
 * \param none
 *
 * \return none
 */
void rf_cca_timer_interrupt(void)
{
}


/*
 * \brief Function starts the ACK wait timeout.
 *
 * \param slots Given slots, resolution 50us
 *
 * \return none
 */
void rf_ack_wait_timer_start(uint16_t slots)
{
}

/*
 * \brief Function starts the calibration interval.
 *
 * \param slots Given slots, resolution 50us
 *
 * \return none
 */
void rf_calibration_timer_start(uint32_t slots)
{
}

/*
 * \brief Function starts the CCA timout.
 *
 * \param slots Given slots, resolution 50us
 *
 * \return none
 */
void rf_cca_timer_start(uint32_t slots)
{
}

/*
 * \brief Function stops the ACK wait timeout.
 *
 * \param none
 *
 * \return none
 */
void rf_ack_wait_timer_stop(void)
{
}

/*
 * \brief Function reads the MAC address array.
 *
 * \param ptr Pointer to read array
 *
 * \return none
 */
void rf_read_mac_address(uint8_t *ptr)
{
    memcpy(ptr, MAC_address, 8);
}

/*
 * \brief Function sets the MAC address array.
 *
 * \param ptr Pointer to given MAC address array
 *
 * \return none
 */
void rf_set_mac_address(const uint8_t *ptr)
{
    memcpy(MAC_address, ptr, 8);
}

uint16_t rf_get_phy_mtu_size(void)
{
    return device_driver.phy_MTU;
}

/*
 * \brief Function writes various RF settings in startup.
 *
 * \param none
 *
 * \return none
 */
void rf_write_settings(void)
{
}

/*
 * \brief Function writes 16-bit address in RF address filter.
 *
 * \param short_address Given short address
 *
 * \return none
 */
void rf_set_short_adr(uint8_t * short_address)
{
    uint8_t data[2];

    data[0] = short_address[1];
    data[1] = short_address[0];    
    MCR20Drv_IndirectAccessSPIMultiByteWrite(MACSHORTADDRS0_LSB, data, 2);
}

/*
 * \brief Function writes PAN Id in RF PAN Id filter.
 *
 * \param pan_id Given PAN Id
 *
 * \return none
 */
void rf_set_pan_id(uint8_t *pan_id)
{
    uint8_t data[2];

    data[0] = pan_id[1];
    data[1] = pan_id[0];
    MCR20Drv_IndirectAccessSPIMultiByteWrite(MACPANID0_LSB, data, 2);
}

/*
 * \brief Function writes 64-bit address in RF address filter.
 *
 * \param address Given 64-bit address
 *
 * \return none
 */
void rf_set_address(uint8_t *address)
{
    uint8_t data[8];
    
    data[0] = address[7];
    data[1] = address[6];
    data[2] = address[5];
    data[3] = address[4];
    data[4] = address[3];
    data[5] = address[2];
    data[6] = address[1];
    data[7] = address[0];
    MCR20Drv_IndirectAccessSPIMultiByteWrite(MACLONGADDRS0_0, data, 8);
}

/*
 * \brief Function sets the RF channel.
 *
 * \param ch New channel
 *
 * \return none
 */
void rf_channel_set(uint8_t channel)
{
    rf_phy_channel = channel;
    MCR20Drv_DirectAccessSPIWrite(PLL_INT0, pll_int[channel - 11]);
    MCR20Drv_DirectAccessSPIMultiByteWrite(PLL_FRAC0_LSB, (uint8_t *) &pll_frac[channel - 11], 2);
}


/*
 * \brief Function initialises the radio driver and resets the radio.
 *
 * \param none
 *
 * \return none
 */
void rf_init(void)
{
    int index;
    extern uint32_t mPhyIrqDisableCnt;

    mPhySeqState = gIdle_c;
    /*Reset RF module*/
    MCR20Drv_RESET();
    /* Initialize the transceiver SPI driver */
    MCR20Drv_Init();
    /* Disable Tristate on MISO for SPI reads */
    MCR20Drv_IndirectAccessSPIWrite(MISC_PAD_CTRL, 0x02);
    /* Set XCVR clock output settings */
    MCR20Drv_Set_CLK_OUT_Freq(gMCR20_ClkOutFreq_d);
    /* PHY_CTRL1 default HW settings  + AUTOACK enabled */
    MCR20Drv_DirectAccessSPIWrite(PHY_CTRL1, cPHY_CTRL1_AUTOACK);
    /* PHY_CTRL2 : mask all PP interrupts */
    MCR20Drv_DirectAccessSPIWrite(PHY_CTRL2, (cPHY_CTRL2_CRC_MSK | \
                                              cPHY_CTRL2_PLL_UNLOCK_MSK | \
                                              cPHY_CTRL2_FILTERFAIL_MSK | \
                                              cPHY_CTRL2_RX_WMRK_MSK | \
                                              cPHY_CTRL2_CCAMSK | \
                                              cPHY_CTRL2_RXMSK | \
                                              cPHY_CTRL2_TXMSK | \
                                              cPHY_CTRL2_SEQMSK));
    /* PHY_CTRL3 : enable all timers and disable remaining interrupts */
    MCR20Drv_DirectAccessSPIWrite(PHY_CTRL3, (cPHY_CTRL3_ASM_MSK    | \
                                              cPHY_CTRL3_PB_ERR_MSK | \
                                              cPHY_CTRL3_WAKE_MSK   | \
                                              cPHY_CTRL3_TMR1CMP_EN | \
                                              cPHY_CTRL3_TMR2CMP_EN | \
                                              cPHY_CTRL3_TMR3CMP_EN | \
                                              cPHY_CTRL3_TMR4CMP_EN));
    /* Clear all PP IRQ bits to avoid unexpected interrupts immediately after initialization */
    MCR20Drv_DirectAccessSPIWrite(IRQSTS1, (cIRQSTS1_PLL_UNLOCK_IRQ | \
                                            cIRQSTS1_FILTERFAIL_IRQ | \
                                            cIRQSTS1_RXWTRMRKIRQ | \
                                            cIRQSTS1_CCAIRQ | \
                                            cIRQSTS1_RXIRQ | \
                                            cIRQSTS1_TXIRQ | \
                                            cIRQSTS1_SEQIRQ));
    
    MCR20Drv_DirectAccessSPIWrite(IRQSTS2, (cIRQSTS2_ASM_IRQ | cIRQSTS2_PB_ERR_IRQ | cIRQSTS2_WAKE_IRQ));
    /* Mask and clear all TMR IRQs */
    MCR20Drv_DirectAccessSPIWrite(IRQSTS3, (cIRQSTS3_TMR4MSK | cIRQSTS3_TMR3MSK | cIRQSTS3_TMR2MSK | cIRQSTS3_TMR1MSK | \
                                            cIRQSTS3_TMR4IRQ | cIRQSTS3_TMR3IRQ | cIRQSTS3_TMR2IRQ | cIRQSTS3_TMR1IRQ));
    /* PHY_CTRL4 unmask global TRX interrupts, enable 16 bit mode for TC2 - TC2 prime EN */
    MCR20Drv_DirectAccessSPIWrite(PHY_CTRL4, cPHY_CTRL4_TC2PRIME_EN | (gCcaCCA_MODE1_c << cPHY_CTRL4_CCATYPE_Shift_c));
    /*  RX_FRAME_FILTER. Accept FrameVersion 0 and 1 packets, reject all others */
    MCR20Drv_IndirectAccessSPIWrite(RX_FRAME_FILTER, (cRX_FRAME_FLT_FRM_VER | \
                                                      cRX_FRAME_FLT_BEACON_FT | \
                                                      cRX_FRAME_FLT_DATA_FT | \
                                                      cRX_FRAME_FLT_CMD_FT ));
    /* Direct register overwrites */
    for (index = 0; index < sizeof(overwrites_direct)/sizeof(overwrites_t); index++)
        MCR20Drv_DirectAccessSPIWrite(overwrites_direct[index].address, overwrites_direct[index].data);
    /* Indirect register overwrites */
    for (index = 0; index < sizeof(overwrites_indirect)/sizeof(overwrites_t); index++)
        MCR20Drv_IndirectAccessSPIWrite(overwrites_indirect[index].address, overwrites_indirect[index].data);

    /* Set the CCA energy threshold value */
    MCR20Drv_IndirectAccessSPIWrite(CCA1_THRESH, RF_CCA_THRESHOLD);
    /* Set prescaller to obtain 1 symbol (16us) timebase */
    MCR20Drv_IndirectAccessSPIWrite(TMR_PRESCALE, 0x05);

    MCR20Drv_IRQ_Enable();

    /*Read random variable. This will be used when seeding pseudo-random generator*/
    rf_rnd_rssi = rf_if_read_rnd();
    /*Start receiver*/
    rf_receive();
}

/**
 * \brief Function gets called when MAC is setting radio off.
 *
 * \param none
 *
 * \return none
 */
void rf_off(void)
{
    PhyAbort();
}

/*
 * \brief Function polls the RF state until it has changed to desired state.
 *
 * \param trx_state RF state
 *
 * \return none
 */
void rf_poll_trx_state_change(rf_trx_states_t trx_state)
{
}

/*
 * \brief Function starts the CCA process before starting data transmission and copies the data to RF TX FIFO.
 *
 * \param data_ptr Pointer to TX data
 * \param data_length Length of the TX data
 * \param tx_handle Handle to transmission
 * \return 0 Success
 * \return -1 Busy
 */
int8_t rf_start_cca(uint8_t *data_ptr, uint16_t data_length, uint8_t tx_handle, data_protocol_e data_protocol )
{
    uint8_t phyRegs[5];
    
    /* Parameter validation */
    if( !data_ptr || (data_length > 125) || (PHY_LAYER_PAYLOAD != data_protocol) )
    {
        return -1;
    }

    if( mPhySeqState == gRX_c )
    {
        PhyAbort();
    }

    /*Check if transmitter is busy*/
    if( mPhySeqState != gIdle_c )
    {
        /*Return busy*/
        return -1;
    }

    /*Store TX handle*/
    mac_tx_handle = tx_handle;

    /*Check if transmitted data needs to be acked*/
    need_ack = (*data_ptr & 0x20) == 0x20;

    /* Load data into XCVR */
    tx_len = data_length + 2;
    rf_buffer[0] = tx_len;
    memcpy(rf_buffer + 1, data_ptr, data_length);
    MCR20Drv_PB_SPIBurstWrite(rf_buffer, data_length + 1);
    
    /* Read XCVR registers */
    phyRegs[0] = MCR20Drv_DirectAccessSPIMultiByteRead(IRQSTS2, &phyRegs[1], 4);
    phyRegs[PHY_CTRL1] &= ~(cPHY_CTRL1_XCVSEQ);
    phyRegs[PHY_CTRL1] |= gCCA_c;
    mPhySeqState = gCCA_c;

    /* Ensure that no spurious interrupts are raised */
    phyRegs[IRQSTS3] &= 0xF0; /* do not change other IRQ status */
    phyRegs[IRQSTS3] |= (cIRQSTS3_TMR3MSK | cIRQSTS3_TMR2IRQ | cIRQSTS3_TMR3IRQ);
    MCR20Drv_DirectAccessSPIMultiByteWrite(IRQSTS1, phyRegs, 3);

    /* Write XCVR settings */
    MCR20Drv_DirectAccessSPIWrite(PHY_CTRL1, phyRegs[PHY_CTRL1]);
    
    /* Unmask SEQ interrupt */
    phyRegs[PHY_CTRL2] &= ~(cPHY_CTRL2_SEQMSK);
    MCR20Drv_DirectAccessSPIWrite(PHY_CTRL2, phyRegs[PHY_CTRL2]);

    /*Return success*/
    return 0;
}

/*
 * \brief Function aborts CCA process.
 *
 * \param none
 *
 * \return none
 */
void rf_cca_abort(void)
{
    PhyAbort();
}


/*
 * \brief Function starts the transmission of the frame.
 *
 * \param none
 *
 * \return none
 */
void rf_start_tx(void)
{
    /* Perform TxRxAck sequence if required by phyTxMode */
    if( need_ack )
    {
        mStatusAndControlRegs[PHY_CTRL1] |= (uint8_t) (cPHY_CTRL1_RXACKRQD);
        mPhySeqState = gTR_c;
    }
    else
    {
        mStatusAndControlRegs[PHY_CTRL1] &= (uint8_t) ~(cPHY_CTRL1_RXACKRQD);
        mPhySeqState = gTX_c;
    }

    mStatusAndControlRegs[PHY_CTRL1] &= ~(cPHY_CTRL1_XCVSEQ);
    mStatusAndControlRegs[PHY_CTRL1] |= mPhySeqState;
    
    /* Unmask SEQ interrupt */
    mStatusAndControlRegs[PHY_CTRL2] &= ~(cPHY_CTRL2_SEQMSK);

    /* Start the sequence immediately */
    MCR20Drv_DirectAccessSPIMultiByteWrite(PHY_CTRL1, &mStatusAndControlRegs[PHY_CTRL1], 2);

    if( need_ack )
    {
        uint32_t timeout;

        PhyTimeReadClock(&timeout);
        timeout += gPhyWarmUpTime_c + gPhySHRDuration_c + tx_len * gPhySymbolsPerOctet_c + gPhyAckWaitDuration_c;
        PhyTimeSetEventTimeout(&timeout);
    }
}

/*
 * \brief Function sets the RF in RX state.
 *
 * \param none
 *
 * \return none
 */
void rf_receive(void)
{
    uint8_t phyRegs[5];

    /* RX can start only from Idle state */
    if( mPhySeqState != gIdle_c )
    {
        return;
    }

    /* read XVCR settings */
    phyRegs[IRQSTS1] = MCR20Drv_DirectAccessSPIMultiByteRead(IRQSTS2, &phyRegs[IRQSTS2], 4);
    /* unmask SEQ interrupt */
    phyRegs[PHY_CTRL2] &= ~(cPHY_CTRL2_SEQMSK);
    /* set XcvrSeq to RX */
    phyRegs[PHY_CTRL1] &= ~(cPHY_CTRL1_XCVSEQ);
    phyRegs[PHY_CTRL1] |=  gRX_c;
    mPhySeqState = gRX_c;
    /* Ensure that no spurious interrupts are raised */
    phyRegs[IRQSTS3] &= 0xF0; /* do not change other IRQ status */
    phyRegs[IRQSTS3] |= cIRQSTS3_TMR3MSK | cIRQSTS3_TMR3IRQ;
    /* sync settings with XCVR */
    MCR20Drv_DirectAccessSPIMultiByteWrite(IRQSTS1, phyRegs, 5);
}

/*
 * \brief Function calibrates the radio.
 *
 * \param none
 *
 * \return none
 */
void rf_calibration_cb(void)
{
}

/*
 * \brief Function sets RF_ON flag when radio is powered.
 *
 * \param none
 *
 * \return none
 */
void rf_on(void)
{
}

/*
 * \brief Function handles the received ACK frame.
 *
 * \param seq_number Sequence number of received ACK
 * \param data_pending Pending bit state in received ACK
 *
 * \return none
 */
void rf_handle_ack(uint8_t seq_number, uint8_t data_pending)
{
}

/*
 * \brief Function is a call back for RX end interrupt.
 *
 * \param none
 *
 * \return none
 */
void rf_handle_rx_end(void)
{
    uint8_t rf_lqi = MCR20Drv_DirectAccessSPIRead(LQI_VALUE);
    int8_t rf_rssi = 0;
    uint8_t len = mStatusAndControlRegs[RX_FRM_LEN] - 2;
    

    /*Start receiver*/
    rf_receive();

    /*Check the length is valid*/
    if(len > 1 && len < RF_BUFFER_SIZE)
    {
        rf_lqi  = Phy_LqiConvert(rf_lqi);
        rf_rssi = PhyConvertLQIToRSSI(rf_lqi);

        /*Read received packet*/
        MCR20Drv_PB_SPIBurstRead(rf_buffer, len);
        arm_net_phy_rx(PHY_LAYER_PAYLOAD, rf_buffer, len, rf_lqi, rf_rssi, rf_radio_driver_id);
    }
}

/*
 * \brief Function is called when MAC is shutting down the radio.
 *
 * \param none
 *
 * \return none
 */
void rf_shutdown(void)
{
    /*Call RF OFF*/
    rf_off();
}

/*
 * \brief Function is a call back for TX end interrupt.
 *
 * \param none
 *
 * \return none
 */
void rf_handle_tx_end(void)
{
    /*Start receiver*/
    rf_receive();

    /*Call PHY TX Done API*/
    if( need_ack )
    {
        if( mStatusAndControlRegs[IRQSTS1] & cIRQSTS1_RX_FRM_PEND )
        {
            arm_net_phy_tx_done(rf_radio_driver_id, mac_tx_handle, PHY_LINK_TX_DONE_PENDING, 1, 1);
        }
        else
        {
            // arm_net_phy_tx_done(rf_radio_driver_id, mac_tx_handle, PHY_LINK_TX_SUCCESS, 1, 1);
            arm_net_phy_tx_done(rf_radio_driver_id, mac_tx_handle, PHY_LINK_TX_DONE, 1, 1);
        }
    }
    else
    {
        arm_net_phy_tx_done(rf_radio_driver_id, mac_tx_handle, PHY_LINK_TX_SUCCESS, 1, 1);
    }
}

/*
 * \brief Function is a call back for CCA ED done interrupt.
 *
 * \param none
 *
 * \return none
 */
void rf_handle_cca_ed_done(void)
{
    /*Check the result of CCA process*/
    if( !(mStatusAndControlRegs[IRQSTS2] & cIRQSTS2_CCA) ) 
    {
        rf_start_tx();
    }
    else
    {
        /*Send CCA fail notification*/
        arm_net_phy_tx_done(rf_radio_driver_id, mac_tx_handle, PHY_LINK_CCA_FAIL, 1, 1);
    }
}

/*
 * \brief Function sets the TX power variable.
 *
 * \param power TX power setting
 *
 * \return 0 Success
 * \return -1 Fail
 */
int8_t rf_tx_power_set(uint8_t power)
{
    /* -40 dBm to 16 dBm */
    if((power < 3) || (power > 31))
    {
        return -1;;
    }

    radio_tx_power = power;
    MCR20Drv_DirectAccessSPIWrite(PA_PWR, power);
    return 0;
}

/*
 * \brief Function returns the TX power variable.
 *
 * \param none
 *
 * \return radio_tx_power TX power variable
 */
uint8_t rf_tx_power_get(void)
{
  return radio_tx_power;
}

/*
 * \brief Function enables the usage of Antenna diversity.
 *
 * \param none
 *
 * \return 0 Success
 */
int8_t rf_enable_antenna_diversity(void)
{
    uint8_t phyReg;

    phyReg = MCR20Drv_IndirectAccessSPIRead(ANT_AGC_CTRL);
    phyReg |= cANT_AGC_CTRL_FAD_EN_Mask_c;
    MCR20Drv_IndirectAccessSPIWrite(ANT_AGC_CTRL, phyReg);

    phyReg = MCR20Drv_IndirectAccessSPIRead(ANT_PAD_CTRL);
    phyReg |= 0x02;
    MCR20Drv_IndirectAccessSPIWrite(ANT_PAD_CTRL, phyReg);
    
    return 0;
}

/*
 * \brief Function gives the control of RF states to MAC.
 *
 * \param new_state RF state
 * \param rf_channel RF channel
 *
 * \return 0 Success
 */
static int8_t rf_interface_state_control(phy_interface_state_e new_state, uint8_t rf_channel)
{
    int8_t ret_val = 0;
    switch (new_state)
    {
        /*Reset PHY driver and set to idle*/
        case PHY_INTERFACE_RESET:
            break;
        /*Disable PHY Interface driver*/
        case PHY_INTERFACE_DOWN:
            rf_shutdown();
            break;
        /*Enable PHY Interface driver*/
        case PHY_INTERFACE_UP:
            rf_channel_set(rf_channel);
            rf_receive();
            break;
        /*Enable wireless interface ED scan mode*/
        case PHY_INTERFACE_RX_ENERGY_STATE:
            break;
        case PHY_INTERFACE_SNIFFER_STATE:             /**< Enable Sniffer state */
            PhyPpSetPromiscuous(1);
            rf_channel_set(rf_channel);
            rf_receive();
            break;
    }
    return ret_val;
}

/*
 * \brief Function controls the ACK pending, channel setting and energy detection.
 *
 * \param extension_type Type of control
 * \param data_ptr Data from NET library
 *
 * \return 0 Success
 */
static int8_t rf_extension(phy_extension_type_e extension_type, uint8_t *data_ptr)
{
    switch (extension_type)
    {
        /*Control MAC pending bit for Indirect data transmission*/
        case PHY_EXTENSION_CTRL_PENDING_BIT:
        {
            uint8_t reg = MCR20Drv_DirectAccessSPIRead(SRC_CTRL);

            if(*data_ptr)
            {
                reg |= cSRC_CTRL_ACK_FRM_PND;
            }
            else
            {
                reg &= ~cSRC_CTRL_ACK_FRM_PND;
            }
            
            MCR20Drv_DirectAccessSPIWrite(SRC_CTRL, reg);
            break;
            
        }
        /*Return frame pending status*/
        case PHY_EXTENSION_READ_LAST_ACK_PENDING_STATUS:
            *data_ptr = MCR20Drv_DirectAccessSPIRead(IRQSTS1 & cIRQSTS1_RX_FRM_PEND);
            break;
        /*Set channel*/
        case PHY_EXTENSION_SET_CHANNEL:
            break;
        /*Read energy on the channel*/
        case PHY_EXTENSION_READ_CHANNEL_ENERGY:
            break;
        /*Read status of the link*/
        case PHY_EXTENSION_READ_LINK_STATUS:
            break;
    }
    return 0;
}

/*
 * \brief Function sets the addresses to RF address filters.
 *
 * \param address_type Type of address
 * \param address_ptr Pointer to given address
 *
 * \return 0 Success
 */
static int8_t rf_address_write(phy_address_type_e address_type, uint8_t *address_ptr)
{
    int8_t ret_val = 0;
    switch (address_type)
    {
        /*Set 48-bit address*/
        case PHY_MAC_48BIT:
            break;
            /*Set 64-bit address*/
        case PHY_MAC_64BIT:
            rf_set_address(address_ptr);
            break;
        /*Set 16-bit address*/
        case PHY_MAC_16BIT:
            rf_set_short_adr(address_ptr);
            break;
        /*Set PAN Id*/
        case PHY_MAC_PANID:
            rf_set_pan_id(address_ptr);
            break;
    }
    return ret_val;
}

/*
 * \brief Function initialises the ACK wait time and returns the used PHY mode.
 *
 * \param none
 *
 * \return tmp Used PHY mode
 */
void rf_init_phy_mode(void)
{
}


uint8_t rf_scale_lqi(int8_t rssi)
{
    return (rssi * 163 + 16820) / 50;
}

/*
 * \brief Function is a RF interrupt vector. End of frame in RX and TX are handled here as well as CCA process interrupt.
 *
 * \param none
 *
 * \return none
 */
void PHY_InterruptHandler(void)
{
    uint8_t xcvseqCopy;

    /* Disable and clear transceiver(IRQ_B) interrupt */
    MCR20Drv_IRQ_Disable();
    //MCR20Drv_IRQ_Clear();

    /* Read transceiver interrupt status and control registers */
    mStatusAndControlRegs[IRQSTS1] =
        MCR20Drv_DirectAccessSPIMultiByteRead(IRQSTS2, &mStatusAndControlRegs[IRQSTS2], 7);
    xcvseqCopy = mStatusAndControlRegs[PHY_CTRL1] & cPHY_CTRL1_XCVSEQ;

    /* Sequencer interrupt, the autosequence has completed */
    if( (mStatusAndControlRegs[IRQSTS1] & cIRQSTS1_SEQIRQ) && 
       !(mStatusAndControlRegs[PHY_CTRL2] & cPHY_CTRL2_SEQMSK) )
    {
        /* Set XCVR to Idle */
        mPhySeqState = gIdle_c;
        mStatusAndControlRegs[PHY_CTRL1] &=  ~( cPHY_CTRL1_XCVSEQ );
        /* Mask interrupts */
        mStatusAndControlRegs[PHY_CTRL2] |= cPHY_CTRL2_CCAMSK | cPHY_CTRL2_RXMSK | cPHY_CTRL2_TXMSK | cPHY_CTRL2_SEQMSK;
        /* Sync settings with XCVR */
        MCR20Drv_DirectAccessSPIMultiByteWrite(IRQSTS1, mStatusAndControlRegs, 5);
                                                               
        /* PLL unlock, the autosequence has been aborted due to PLL unlock */
        if( mStatusAndControlRegs[IRQSTS1] & cIRQSTS1_PLL_UNLOCK_IRQ )
        {
            if(xcvseqCopy == gRX_c)
            {
                rf_receive();
            }
            MCR20Drv_IRQ_Enable();
            return;
        }
        
        /* TMR3 timeout, the autosequence has been aborted due to TMR3 timeout */
        if( (mStatusAndControlRegs[IRQSTS3] & cIRQSTS3_TMR3IRQ) &&
           !(mStatusAndControlRegs[IRQSTS1] & cIRQSTS1_RXIRQ) &&
            (xcvseqCopy == gTR_c) )
        {
            rf_ack_wait_timer_interrupt();
            MCR20Drv_IRQ_Enable();
            return;
        }

        switch(xcvseqCopy)
        {
        case gTX_c:
        case gTR_c:
            rf_handle_tx_end();
            break;

        case gRX_c:
            rf_handle_rx_end();
            break;

        case gCCA_c:
            rf_handle_cca_ed_done();
            break;

        default:
            break;
        }
        
        MCR20Drv_IRQ_Enable();
        return;
    }
    /* Other IRQ. Clear XCVR interrupt flags */
    MCR20Drv_DirectAccessSPIMultiByteWrite(IRQSTS1, mStatusAndControlRegs, 3);
    MCR20Drv_IRQ_Enable();
}

static void PhyAbort(void)
{
    /* Mask XCVR irq */
    MCR20Drv_IRQ_Disable();

    mPhySeqState = gIdle_c;

    mStatusAndControlRegs[IRQSTS1] = MCR20Drv_DirectAccessSPIMultiByteRead(IRQSTS2, &mStatusAndControlRegs[IRQSTS2], sizeof(mStatusAndControlRegs) - 1);

    if( (mStatusAndControlRegs[PHY_CTRL1] & cPHY_CTRL1_XCVSEQ) != gIdle_c )
    {
        /* Abort current SEQ */
        mStatusAndControlRegs[PHY_CTRL1] &= ~(cPHY_CTRL1_XCVSEQ);
        MCR20Drv_DirectAccessSPIWrite(PHY_CTRL1, mStatusAndControlRegs[PHY_CTRL1]);
        
        /* Wait for Sequence Idle (if not already) */
        while ((MCR20Drv_DirectAccessSPIRead(SEQ_STATE) & 0x1F) != 0);
        //while ( !(MCR20Drv_DirectAccessSPIRead(IRQSTS1) & cIRQSTS1_SEQIRQ));
        mStatusAndControlRegs[IRQSTS1] |= cIRQSTS1_SEQIRQ;
    }

    /* Mask SEQ interrupt */
    mStatusAndControlRegs[PHY_CTRL2] |= cPHY_CTRL2_SEQMSK;

    /* Stop timers */
    mStatusAndControlRegs[PHY_CTRL3] &= ~(cPHY_CTRL3_TMR2CMP_EN | cPHY_CTRL3_TMR3CMP_EN);
    mStatusAndControlRegs[PHY_CTRL4] &= ~(cPHY_CTRL4_TC3TMOUT);
    MCR20Drv_DirectAccessSPIMultiByteWrite(PHY_CTRL2, &mStatusAndControlRegs[PHY_CTRL2], 4);

    /* Clear all PP IRQ bits to avoid unexpected interrupts and mask TMR3 interrupt.
       Do not change TMR IRQ status. */
    mStatusAndControlRegs[IRQSTS3] &= 0xF0;
    mStatusAndControlRegs[IRQSTS3] |= (cIRQSTS3_TMR3MSK | cIRQSTS3_TMR2MSK | cIRQSTS3_TMR2IRQ | cIRQSTS3_TMR3IRQ);
    MCR20Drv_DirectAccessSPIMultiByteWrite(IRQSTS1, mStatusAndControlRegs, 3);

    /* Unmask XCVR irq */
    MCR20Drv_IRQ_Enable();
}

static void PhyTimeReadClock(uint32_t *pRetClk)
{
    if(NULL == pRetClk)
    {
        return;
    }

    platform_enter_critical();

    *pRetClk = 0;
    MCR20Drv_DirectAccessSPIMultiByteRead(EVENT_TMR_LSB, (uint8_t *) pRetClk, 3);

    platform_exit_critical();
}

static void PhyTimeSetEventTimeout(uint32_t *pEndTime)
{
    uint8_t phyReg;
    
    if(NULL == pEndTime)
    {
        return;
    }
    
    platform_enter_critical();
    
    phyReg = MCR20Drv_DirectAccessSPIRead(IRQSTS3);
    phyReg &= 0xF0;                    /* do not change IRQ status */
    phyReg |= (cIRQSTS3_TMR3MSK);      /* mask TMR3 interrupt */
    MCR20Drv_DirectAccessSPIWrite( (uint8_t) IRQSTS3, phyReg);
    
    MCR20Drv_DirectAccessSPIMultiByteWrite( (uint8_t) T3CMP_LSB, (uint8_t *) pEndTime, 3);
    
    phyReg &= ~(cIRQSTS3_TMR3MSK);      /* unmask TMR3 interrupt */
    phyReg |= (cIRQSTS3_TMR3IRQ);       /* aknowledge TMR3 IRQ */
    MCR20Drv_DirectAccessSPIWrite( (uint8_t) IRQSTS3, phyReg);
    
    platform_exit_critical();
}

static uint8_t rf_if_read_rnd(void)
{
    uint8_t phyReg;
    uint32_t startTime, endTime;
    

    MCR20Drv_IRQ_Disable();

    PhyTimeReadClock(&startTime);

    /* Program a new sequence */
    phyReg = MCR20Drv_DirectAccessSPIRead(PHY_CTRL1);
    MCR20Drv_DirectAccessSPIWrite( PHY_CTRL1, phyReg | gRX_c);

    /* Wait a number of symbols */
    do
      PhyTimeReadClock(&endTime);
    while( ((endTime - startTime) & 0x00FFFFFF) < 16 );

    /* Abort the sequence */
    PhyAbort();

    MCR20Drv_IRQ_Enable();

    return MCR20Drv_IndirectAccessSPIRead((uint8_t)_RNG);
}

int8_t PhyConvertLQIToRSSI(uint8_t lqi)
{
    int32_t rssi = (50*lqi - 16820) / 163;
    return (int8_t)rssi;
}

static uint8_t Phy_LqiConvert(uint8_t hwLqi)
{
    uint32_t tmpLQI;

    /* LQI Saturation Level */
    if (hwLqi >= 230)
    {
        return 0xFF;
    }
    else if (hwLqi <= 9)
    {
        return 0;
    }
    else
    {
        /* Rescale the LQI values from min to saturation to the 0x00 - 0xFF range */
        /* The LQI value mst be multiplied by ~1.1087 */
        /* tmpLQI =  hwLqi * 7123 ~= hwLqi * 65536 * 0.1087 = hwLqi * 2^16 * 0.1087*/
        tmpLQI = ((uint32_t)hwLqi * (uint32_t)7123 );
        /* tmpLQI =  (tmpLQI / 2^16) + hwLqi */
        tmpLQI = (uint32_t)(tmpLQI >> 16) + (uint32_t)hwLqi;

        return (uint8_t)tmpLQI;
    }
}

static void PhyPpSetPromiscuous(uint8_t mode)
{
  uint8_t rxFrameFltReg, phyCtrl4Reg;

  rxFrameFltReg = MCR20Drv_IndirectAccessSPIRead(RX_FRAME_FILTER);
  phyCtrl4Reg = MCR20Drv_DirectAccessSPIRead(PHY_CTRL4);

  if( mode )
  {
    /* FRM_VER[1:0] = b00. 00: Any FrameVersion accepted (0,1,2 & 3) */
    /* All frame types accepted*/
    phyCtrl4Reg |= cPHY_CTRL4_PROMISCUOUS;
    rxFrameFltReg &= ~(cRX_FRAME_FLT_FRM_VER);
    rxFrameFltReg |=  (cRX_FRAME_FLT_ACK_FT | cRX_FRAME_FLT_NS_FT);
  }
  else
  {
    phyCtrl4Reg &= ~cPHY_CTRL4_PROMISCUOUS;
    /* FRM_VER[1:0] = b11. Accept FrameVersion 0 and 1 packets, reject all others */
    /* Beacon, Data and MAC command frame types accepted */
    rxFrameFltReg &= ~(cRX_FRAME_FLT_FRM_VER);
    rxFrameFltReg |= (0x03 << cRX_FRAME_FLT_FRM_VER_Shift_c);
    rxFrameFltReg &= ~(cRX_FRAME_FLT_ACK_FT | cRX_FRAME_FLT_NS_FT);
  }

  MCR20Drv_IndirectAccessSPIWrite(RX_FRAME_FILTER, rxFrameFltReg);
  MCR20Drv_DirectAccessSPIWrite(PHY_CTRL4, phyCtrl4Reg);
}
